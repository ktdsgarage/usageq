def PIPELINE_ID = "usageq-${env.BUILD_NUMBER}"

def getImageTag() {
    def dateFormat = new java.text.SimpleDateFormat('yyyyMMddHHmmss')
    def currentDate = new Date()
    return dateFormat.format(currentDate)
}

def checkError(message) {
    if (currentBuild.result == "FAILURE") {
        error "Failed: ${message}"
    }
}

// 변경된 파일 목록을 기반으로 서비스별 빌드 여부 결정
def shouldBuildService(service) {
    def changedFiles = sh(script: "git diff --name-only HEAD^", returnStdout: true).trim()

    // common 모듈이 변경된 경우 모든 서비스 빌드
    if (changedFiles.contains("common/")) {
        echo "Common module changed. Building all services."
        return true
    }

    // 특정 서비스의 변경사항이 있는 경우만 해당 서비스 빌드
    return changedFiles.contains("${service}/")
}

// 변경사항 있는지 체크하는 헬퍼 함수
def hasChanges(buildFlags) {
    return buildFlags.management || buildFlags.query || buildFlags.update
}

podTemplate(
    label: "${PIPELINE_ID}",
    serviceAccount: 'jenkins',
    containers: [
        containerTemplate(name: 'gradle', image: 'gradle:jdk17', ttyEnabled: true, command: 'cat'),
        containerTemplate(name: 'podman', image: "mgoltzsche/podman", ttyEnabled: true, command: 'cat', privileged: true),
        containerTemplate(
            name: 'azure-cli',
            image: 'hiondal/azure-kubectl:latest',
            command: 'cat',
            ttyEnabled: true,
            envVars: [
                envVar(key: 'HOME', value: '/home/jenkins')
            ]
        ),
        containerTemplate(name: 'envsubst', image: "hiondal/envsubst", command: 'sleep', args: '1h')
    ],
    volumes: [
        emptyDirVolume(mountPath: '/home/gradle/.gradle', memory: false),
        emptyDirVolume(mountPath: '/root/.azure', memory: false)
    ]
) {
    node(PIPELINE_ID) {
        def props
        def imageTag = getImageTag()
        def manifest = "deploy.yaml"

        // 서비스별 빌드 플래그 초기화
        def buildFlags = [
            'management': false,
            'query': false,
            'update': false
        ]

        stage("Get Source") {
            checkout scm
            props = readProperties file: "deployment/deploy_env_vars"

            // 각 서비스별 빌드 여부 확인
            buildFlags.management = shouldBuildService('usage-management-service')
            buildFlags.query = shouldBuildService('usage-query-service')
            buildFlags.update = shouldBuildService('usage-update-service')

            echo "Build flags: ${buildFlags}"
        }

        try {
            stage("Setup AKS") {
                if (hasChanges(buildFlags)) {
                    container('azure-cli') {
                        withCredentials([azureServicePrincipal('azure-credentials')]) {
                            sh """
                                az login --service-principal -u \$AZURE_CLIENT_ID -p \$AZURE_CLIENT_SECRET -t \$AZURE_TENANT_ID
                                az aks get-credentials --resource-group ${props.resource_group} --name ${props.teamid}-aks --overwrite-existing
                                kubectl create namespace ${props.namespace} --dry-run=client -o yaml | kubectl apply -f -
                            """
                        }
                    }
                    checkError("AKS Setup Failed")
                }
            }

            stage('Build Applications') {
                if (hasChanges(buildFlags)) {
                    container('gradle') {
                        sh "chmod +x gradlew"

                        if (buildFlags.query) {
                            sh "./gradlew usage-query-service:clean usage-query-service:build -x test"
                        }
                        if (buildFlags.management) {
                            sh "./gradlew usage-management-service:clean usage-management-service:build -x test"
                        }
                        if (buildFlags.update) {
                            sh "./gradlew usage-update-service:clean usage-update-service:build -x test"
                        }
                    }
                    checkError("Application Build Failed")
                }
            }

            stage('Build and Push Container Images') {
                if (hasChanges(buildFlags)) {
                    container('podman') {
                        withCredentials([usernamePassword(
                            credentialsId: "${props.image_credential}",
                            usernameVariable: 'USERNAME',
                            passwordVariable: 'PASSWORD'
                        )]) {
                            sh "podman login ${props.registry} --username \$USERNAME --password \$PASSWORD"

                            if (buildFlags.management) {
                                def managementImagePath = "${props.registry}/${props.image_org}/usage-management-service"
                                sh """
                                    podman build -f deployment/Dockerfile-management \
                                        -t ${managementImagePath}:${imageTag} \
                                        -t ${managementImagePath}:latest .
                                    podman push ${managementImagePath}:${imageTag}
                                    podman push ${managementImagePath}:latest
                                """
                            }

                            if (buildFlags.query) {
                                def queryImagePath = "${props.registry}/${props.image_org}/usage-query-service"
                                sh """
                                    podman build -f deployment/Dockerfile-query \
                                        -t ${queryImagePath}:${imageTag} \
                                        -t ${queryImagePath}:latest .
                                    podman push ${queryImagePath}:${imageTag}
                                    podman push ${queryImagePath}:latest
                                """
                            }

                            if (buildFlags.update) {
                                def updateImagePath = "${props.registry}/${props.image_org}/usage-update-service"
                                sh """
                                    podman build -f deployment/Dockerfile-update \
                                        -t ${updateImagePath}:${imageTag} \
                                        -t ${updateImagePath}:latest .
                                    podman push ${updateImagePath}:${imageTag}
                                    podman push ${updateImagePath}:latest
                                """
                            }
                        }
                    }
                    checkError("Container Image Build/Push Failed")
                }
            }

            stage('Generate and Apply Deployment') {
                if (hasChanges(buildFlags)) {
                    container('envsubst') {
                        def envVars = """
                            export namespace=${props.namespace}
                            export resources_requests_cpu=${props.resources_requests_cpu}
                            export resources_requests_memory=${props.resources_requests_memory}
                            export resources_limits_cpu=${props.resources_limits_cpu}
                            export resources_limits_memory=${props.resources_limits_memory}
                            export EVENT_HUB_CONNECTION_STRING='${props.EVENT_HUB_CONNECTION_STRING}'
                            export EVENT_HUB_NAME='${props.EVENT_HUB_NAME}'
                            export STORAGE_CONNECTION_STRING='${props.STORAGE_CONNECTION_STRING}'
                        """

                        // 변경된 서비스의 이미지 태그만 업데이트
                        if (buildFlags.management) {
                            def managementImagePath = "${props.registry}/${props.image_org}/usage-management-service:${imageTag}"
                            envVars += "\nexport management_image_path=${managementImagePath}"
                        }
                        if (buildFlags.query) {
                            def queryImagePath = "${props.registry}/${props.image_org}/usage-query-service:${imageTag}"
                            envVars += "\nexport query_image_path=${queryImagePath}"
                        }
                        if (buildFlags.update) {
                            def updateImagePath = "${props.registry}/${props.image_org}/usage-update-service:${imageTag}"
                            envVars += "\nexport update_image_path=${updateImagePath}"
                        }

                        // 환경변수 설정 및 deployment 파일 생성
                        writeFile file: 'env.sh', text: envVars
                        sh """
                            source env.sh
                            envsubst < deployment/${manifest}.template > deployment/${manifest}
                        """
                    }

                    container('azure-cli') {
                        if (buildFlags.management) {
                            sh """
                                kubectl apply -f deployment/${manifest} -l app=usage-management-service
                                echo "Waiting for management service pods..."
                                kubectl wait --for=condition=ready pod -l "app=usage-management-service" -n ${props.namespace} --timeout=300s
                            """
                        }
                        if (buildFlags.query) {
                            sh """
                                kubectl apply -f deployment/${manifest} -l app=usage-query-service
                                echo "Waiting for query service pods..."
                                kubectl wait --for=condition=ready pod -l "app=usage-query-service" -n ${props.namespace} --timeout=300s
                            """
                        }
                        if (buildFlags.update) {
                            sh """
                                kubectl apply -f deployment/${manifest} -l app=usage-update-service
                                echo "Waiting for update service pods..."
                                kubectl wait --for=condition=ready pod -l "app=usage-update-service" -n ${props.namespace} --timeout=300s
                            """
                        }
                    }
                    checkError("Deployment Failed")
                }
            }

            stage('Verify Deployment') {
                if (hasChanges(buildFlags)) {
                    container('azure-cli') {
                        if (buildFlags.management) {
                            sh """
                                echo "Verifying management service endpoint..."
                                MANAGEMENT_IP=\$(kubectl get svc usage-management-service -n ${props.namespace} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                                echo "Management Service IP: \$MANAGEMENT_IP"

                                if [ -z "\$MANAGEMENT_IP" ]; then
                                    echo "Error: Management Service IP not available"
                                    exit 1
                                fi
                            """
                        }
                        if (buildFlags.query) {
                            sh """
                                echo "Verifying query service endpoint..."
                                QUERY_IP=\$(kubectl get svc usage-query-service -n ${props.namespace} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                                echo "Query Service IP: \$QUERY_IP"

                                if [ -z "\$QUERY_IP" ]; then
                                    echo "Error: Query Service IP not available"
                                    exit 1
                                fi
                            """
                        }
                        if (buildFlags.update) {
                            sh """
                                echo "Verifying update service endpoint..."
                                UPDATE_IP=\$(kubectl get svc usage-update-service -n ${props.namespace} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                                echo "Update Service IP: \$UPDATE_IP"

                                if [ -z "\$UPDATE_IP" ]; then
                                    echo "Error: Update Service IP not available"
                                    exit 1
                                fi
                            """
                        }
                    }
                    checkError("Deployment Verification Failed")
                }
            }

            currentBuild.result = 'SUCCESS'
            echo "**** FINISH ALL STAGES : SUCCESS"

        } catch(e) {
            currentBuild.result = "FAILED"
            echo "**** ERROR: ${e.getMessage()}"
            throw e
        }
    }
}