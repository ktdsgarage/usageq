def PIPELINE_ID = "usageq-${env.BUILD_NUMBER}"

def getImageTag() {
    def dateFormat = new java.text.SimpleDateFormat('yyyyMMddHHmmss')
    def currentDate = new Date()
    return dateFormat.format(currentDate)
}

def checkError(message) {
    if (currentBuild.result == "FAILURE") {
        error "Failed: ${message}"
    }
}

podTemplate(
    label: "${PIPELINE_ID}",
    serviceAccount: 'jenkins',
    containers: [
        containerTemplate(name: 'gradle', image: 'gradle:jdk17', ttyEnabled: true, command: 'cat'),
        containerTemplate(name: 'podman', image: "mgoltzsche/podman", ttyEnabled: true, command: 'cat', privileged: true),
        containerTemplate(
            name: 'azure-cli',
            image: 'hiondal/azure-kubectl:latest',
            command: 'cat',
            ttyEnabled: true,
            envVars: [
                envVar(key: 'HOME', value: '/home/jenkins')
            ]
        ),
        containerTemplate(name: 'envsubst', image: "hiondal/envsubst", command: 'sleep', args: '1h')
    ],
    volumes: [
        emptyDirVolume(mountPath: '/home/gradle/.gradle', memory: false),
        emptyDirVolume(mountPath: '/root/.azure', memory: false)
    ]
) {
    node(PIPELINE_ID) {
        // Environment variables
        def props
        def imageTag = getImageTag()
        def manifest = "deploy.yaml"
        def changedServices = []

        stage("Get Source") {
            checkout scm
            props = readProperties file: "deployment/deploy_env_vars"

            // Detect changed services
            def changes = sh(script: 'git diff --name-only HEAD~1', returnStdout: true).trim()
            if (changes.contains('common/')) {
                changedServices = ['usage-management-service', 'usage-query-service', 'usage-update-service']
            } else {
                if (changes.contains('usage-management-service/')) changedServices.add('usage-management-service')
                if (changes.contains('usage-query-service/')) changedServices.add('usage-query-service')
                if (changes.contains('usage-update-service/')) changedServices.add('usage-update-service')
            }

            if (changedServices.isEmpty()) {
                currentBuild.result = 'SUCCESS'
                return
            }
        }

        try {
            stage("Setup AKS") {
                container('azure-cli') {
                    withCredentials([azureServicePrincipal('azure-credentials')]) {
                        sh """
                            az login --service-principal -u \$AZURE_CLIENT_ID -p \$AZURE_CLIENT_SECRET -t \$AZURE_TENANT_ID
                            az aks get-credentials --resource-group ${props.resource_group} --name ${props.teamid}-aks --overwrite-existing
                            kubectl create namespace ${props.namespace} --dry-run=client -o yaml | kubectl apply -f -
                        """
                    }
                }
                checkError("AKS Setup Failed")
            }

            stage('Build Applications') {
                container('gradle') {
                    changedServices.each { service ->
                        sh """
                            chmod +x gradlew
                            ./gradlew ${service}:clean ${service}:build -x test
                        """
                    }
                }
                checkError("Application Build Failed")
            }

            stage('Build Container Images') {
                container('podman') {
                    changedServices.each { service ->
                        def imagePath = "${props.registry}/${props.image_org}/${service}"
                        sh """
                            podman build -f deployment/Dockerfile-${service} \
                                -t ${imagePath}:${imageTag} \
                                -t ${imagePath}:latest .
                        """
                    }
                }
                checkError("Container Image Build Failed")
            }

            stage('Push Container Images') {
                container('podman') {
                    withCredentials([usernamePassword(
                        credentialsId: "${props.image_credential}",
                        usernameVariable: 'USERNAME',
                        passwordVariable: 'PASSWORD'
                    )]) {
                        sh """
                            podman login ${props.registry} --username \$USERNAME --password \$PASSWORD
                        """

                        changedServices.each { service ->
                            def imagePath = "${props.registry}/${props.image_org}/${service}"
                            sh """
                                podman push ${imagePath}:${imageTag}
                                podman push ${imagePath}:latest
                            """
                        }
                    }
                }
                checkError("Container Image Push Failed")
            }

            stage('Generate Deployment YAML') {
                container('envsubst') {
                    def managementImagePath = "${props.registry}/${props.image_org}/usage-management-service:${imageTag}"
                    def queryImagePath = "${props.registry}/${props.image_org}/usage-query-service:${imageTag}"
                    def updateImagePath = "${props.registry}/${props.image_org}/usage-update-service:${imageTag}"

                    sh """
                        export namespace=${props.namespace}
                        export management_image_path=${managementImagePath}
                        export query_image_path=${queryImagePath}
                        export update_image_path=${updateImagePath}
                        export resources_requests_cpu=${props.resources_requests_cpu}
                        export resources_requests_memory=${props.resources_requests_memory}
                        export resources_limits_cpu=${props.resources_limits_cpu}
                        export resources_limits_memory=${props.resources_limits_memory}

                        # Generate deployment file and output for debugging
                        envsubst < deployment/${manifest}.template > deployment/${manifest}
                        echo "Generated manifest:"
                        cat deployment/${manifest}
                    """
                }
                checkError("Deployment YAML Generation Failed")
            }

            stage('Deploy to AKS') {
                container('azure-cli') {
                    sh """
                        kubectl apply -f deployment/${manifest}

                        # Wait for application pods to be ready
                        echo "Waiting for service pods..."
                        for service in ${changedServices.join(' ')}; do
                            kubectl wait --for=condition=ready pod -l "app=\$service" -n ${props.namespace} --timeout=300s
                        done
                    """
                }
                checkError("Deployment to AKS Failed")
            }

            stage('Verify Deployment') {
                container('azure-cli') {
                    changedServices.each { service ->
                        sh """
                            echo "Verifying \${service} endpoint..."
                            SERVICE_IP=\$(kubectl get svc \${service} -n ${props.namespace} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                            echo "\${service} IP: \$SERVICE_IP"

                            if [ -z "\$SERVICE_IP" ]; then
                                echo "Error: Service IP not available for \${service}"
                                exit 1
                            fi
                        """
                    }
                }
                checkError("Deployment Verification Failed")
            }

            currentBuild.result = 'SUCCESS'
            echo "**** FINISH ALL STAGES : SUCCESS"

        } catch(e) {
            currentBuild.result = "FAILED"
            echo "**** ERROR: ${e.getMessage()}"
            throw e
        }
    }
}